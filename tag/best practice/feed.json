{
    "version": "https://jsonfeed.org/version/1",
    "title": "Dave's Notebook ‚Ä¢ All posts by \"best practice\" tag",
    "description": null,
    "home_page_url": "http://davembush.github.com",
    "items": [
        {
            "id": "http://davembush.github.com/optimizing-angular-for-speed/",
            "url": "http://davembush.github.com/optimizing-angular-for-speed/",
            "title": "Optimizing Angular For Speed",
            "date_published": "2024-10-14T12:34:41.000Z",
            "content_html": "<p>I was recently asked how I would optimize an Angular site for speed. Interestingly, I‚Äôve never written about this explicitly even though I‚Äôve done a lot of work related to this issue.</p>\n<p>For the purposes of this article, I‚Äôm going to assume you have already implemented most of the things that Angular gives you ‚Äúfor free.‚Äù For example, we won‚Äôt discuss ‚ÄúTree Shaking‚Äù or ‚ÄúAOT.‚Äù Those are given.</p>\n<p>Here are my 30 or so tips on how to optimize an Angular application for speed.</p>\n<span id=\"more\"></span>\n<h2 id=\"Change-Detection\"><a href=\"#Change-Detection\" class=\"headerlink\" title=\"Change Detection\"></a>Change Detection</h2><h3 id=\"OnPush-Notification\"><a href=\"#OnPush-Notification\" class=\"headerlink\" title=\"OnPush Notification\"></a>OnPush Notification</h3><p>Much has been written about how Angular Change Detection works, so I‚Äôm not going to go into much detail about this other than reiterate the basics.</p>\n<p>Without OnPush notification, angular will check the component to see if anything changes whenever an event occurs. This means something as simple as a mouse move will cause change detection evaluation.</p>\n<p>With OnPush, change detection on a component will happen only if one of the component‚Äôs properties (field marked with @Input() attribute) has changed or if you‚Äôve explicitly told Angular that a change has occurred.</p>\n<p>In my experience, this isn‚Äôt going to generate enough of a performance difference that you can measure in seconds. But it will make a difference overall and is generally a quick win. So, start here.</p>\n<p>One quick way to ensure all your future components use OnPush when using the CLI to generate components is to ensure you add the OnPush configuration to your Angular.json file.</p>\n<p>You can find a good article about this <a href=\"https://indepth.dev/overriding-angular-schematics/\">here</a>.</p>\n<h3 id=\"Small-Components\"><a href=\"#Small-Components\" class=\"headerlink\" title=\"Small Components\"></a>Small Components</h3><p>OnPush notification is only going to be useful if your components are small. Remember that once change detection has determined the component is dirty and needs to be re-rendered, the WHOLE component will be re-calculated even though there is no Virtual DOM diffing in IVY.</p>\n<h3 id=\"Run-Outside-Zones\"><a href=\"#Run-Outside-Zones\" class=\"headerlink\" title=\"Run Outside Zones\"></a>Run Outside Zones</h3><p>It helps to understand how change detection works in Angular to optimize Angular change detection. Part of that equation is that it hooks into the fired events. This is how, for example, Angular knows it should update your screen when a click event occurs or when data is returned from an HttpClient request.</p>\n<p>But sometimes, we may trigger that event in our code when we know that change detection is unnecessary.</p>\n<p>For example, I have code that runs every 20 seconds to see if we should automatically log the user out. To keep this from running the change detection logic, I run this outside of the Zones logic.</p>\n<p>The specific API you are looking for, is <code>Zones.runOutsideAngular()</code></p>\n<p>Another place to look out for is the time-based RxJS operators such as <code>debounceTime()</code>, <code>throttleTime()</code>, etc. These operators will trigger change detection every time they fire. If you are using them in your code, consider running them outside of the Zones logic or use unpatched versions of the operators.</p>\n<h3 id=\"Turn-Off-Zones\"><a href=\"#Turn-Off-Zones\" class=\"headerlink\" title=\"Turn Off Zones\"></a>Turn Off Zones</h3><p>Change detection might get triggered in multiple ways. And, in fact, your app probably doesn‚Äôt need all of them.</p>\n<p>You can turn things off using <code>__Zone_ignore_on_properties</code>.</p>\n<p>There is more information on this <a href=\"https://github.com/angular/zone.js/blob/master/STANDARD-APIS.md\">here</a>.</p>\n<p>That being said, I‚Äôve done some performance testing and it turns out that <a href=\"../ngzones-performance-impact/\">Change Detection is not the first place to look if your screen is rendering slowly</a>.</p>\n<h3 id=\"Use-Pipes\"><a href=\"#Use-Pipes\" class=\"headerlink\" title=\"Use Pipes\"></a>Use Pipes</h3><p>This tip is only really valuable in the cases where the Functional programming‚Äôs pure functions is relevant.</p>\n<p>The idea behind pure functions, at least as it applies to pipes, is that a pure function will always return the same value when given the same parameters. So, for example, the function <code>Add(a, b)</code> will always return 4 given the parameters 2 and 2.</p>\n<p>Why recompute the value when you give it the same parameters as the previous time you called it?</p>\n<p>Using memoization, you can further take advantage of this optimization on functions that take extra time. This is what Angular Pipes do for you under the hood. But by implementing it yourself, you can cache more than the last value. I‚Äôm talking about the practice of holding onto a computed value and using the parameters as a key to look up the return value. Thus avoiding the computation completely.</p>\n<p>Use this optimization tip intelligently, though. Sometimes, values might be ‚Äúthe same,‚Äù but the content is different. I‚Äôm thinking about times when you would mutate the contents of an object. Say an array you added a value to instead of creating a new array. The array object pointer is still the same, so your pure function will not recompute the return value because the pointer didn‚Äôt change.</p>\n<p>If OnPush isn‚Äôt giving you all the optimization that you are looking for, creating a pure Pipe is the next step along the same lines.</p>\n<p>However, this is one place where I‚Äôd spend the extra time to verify that my ‚Äúoptimization‚Äù isn‚Äôt making the performance worse.</p>\n<h3 id=\"NgRX-Actions\"><a href=\"#NgRX-Actions\" class=\"headerlink\" title=\"NgRX Actions\"></a>NgRX Actions</h3><p>Fire as few NgRX Actions as possible. What that means is that if you can fire one action instead of more than one, you should.</p>\n<p>Why is this? Because every action has to be handled by every effect and reducer in your code even if it doesn‚Äôt need it. Think of ever ofType() call as an IF that has to be evaluated. And, similarly, every on() call in the reducers is another IF that has to be evaluated. These add up.</p>\n<p>See my article about <a href=\"/what-i-learned-writing-smartngrx/\">What I learned writing SmartNgRX</a> for more information on this topic.</p>\n<h3 id=\"Use-NgRX-Selectors\"><a href=\"#Use-NgRX-Selectors\" class=\"headerlink\" title=\"Use NgRX Selectors\"></a>Use NgRX Selectors</h3><p>Many people aren‚Äôt aware that NgRX has a Selector mechanism allowing memoization. When you call the Selector,  if nothing it depends on has changed, you get back the same answer you got the previous time you executed the method without having to run all the code that gave you the answer the first time.</p>\n<p>It also looks a lot cleaner than the <code>() =&gt; state.subState</code> mechanism we started out with.</p>\n<p>Note that parameterized selectors can‚Äôt take advantage of this memoization unless you roll your own.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> selectMemoizedThing = <span class=\"title function_\">createSelector</span>(...);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// vs</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">selectCantBeMemoized</span> = (<span class=\"params\">param</span>) =&gt;</span><br><span class=\"line\">  <span class=\"title function_\">createSelector</span>(... uses param <span class=\"keyword\">in</span> here...)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Don‚Äôt-Bind-to-Computed-Values\"><a href=\"#Don‚Äôt-Bind-to-Computed-Values\" class=\"headerlink\" title=\"Don‚Äôt Bind to Computed Values\"></a>Don‚Äôt Bind to Computed Values</h3><p>If your value is computed, Angular can‚Äôt easily determine if it has changed unless it calculates it.</p>\n<p>There are three ways to solve this issue.</p>\n<p>The first and most popular is to use a pipe, as described above. But it is the least desirable because it still forces the change detector to do more work than necessary.</p>\n<p>The second way to achieve this goal is by assigning a member field the computed value during the component‚Äôs <code>ngOnChanges</code> event. Do this when the computed value uses values all internal to the component.</p>\n<p>Third, you can perform ALL the calculations in a Selector so that the data you need is already available and is easy to detect by the time you are binding.</p>\n<p>Finally, if you can, do the computation on the server so it isn‚Äôt even an issue on the client.</p>\n<p>For more information on this topic see my article <a href=\"../how-to-avoid-binding-to-computed-values-in-angular/\">How to Avoid Binding to Computed Values in Angular</a></p>\n<h3 id=\"NgRX-Features\"><a href=\"#NgRX-Features\" class=\"headerlink\" title=\"NgRX Features\"></a>NgRX Features</h3><p>And while we are on the subject of NgRX, instead of creating one monster state to rule them all in the AppModule, use the Features to only instantiate the store reducers, effects, etc., as you need them.</p>\n<h3 id=\"Use-RxJS-distinct\"><a href=\"#Use-RxJS-distinct\" class=\"headerlink\" title=\"Use RxJS distinct()\"></a>Use RxJS distinct()</h3><p>Did you know that your component is probably re-rendering more times than needed? This is because <code>@Input()</code> values will mark the component every time it thinks it might have received a new value. You can prevent this by using <code>distinctUntilChanged()</code> on the Observable.</p>\n<h3 id=\"Use-RxJX-replay\"><a href=\"#Use-RxJX-replay\" class=\"headerlink\" title=\"Use RxJX replay()\"></a>Use RxJX replay()</h3><p>Another trick you can use is to use <code>replay()</code> on the Observable. There are various ways to configure this, but the advantage is that this is another way to prevent calculations you don‚Äôt need. If the value isn‚Äôt going to change as you render the content multiple times on the screen, you only need to compute once and allow <code>replay()</code> to memoize the return.</p>\n<p>Be careful with this trick though, because using it incorrectly can cause memory leaks.</p>\n<h3 id=\"Use-RxJS-asapScheduler\"><a href=\"#Use-RxJS-asapScheduler\" class=\"headerlink\" title=\"Use RxJS asapScheduler\"></a>Use RxJS asapScheduler</h3><p>There are times when you need to schedule a task to run as soon as possible but asynchronously.</p>\n<p>You might think the best way to do this is by using interval(0) or some other mechanism.</p>\n<p>Maybe you want to use debounceTime(0) or throttleTime(0) to prevent the task from running too often.</p>\n<p>Did you know that RxJS has another scheduler, called the asapScheduler that allows you to run things faster than the default scheduler?</p>\n<p>The default scheduler uses the ‚Äúmacro queue‚Äù. This is what setTimeout() uses. The asapScheduler uses the ‚Äúmicro queue‚Äù which is what Promise.resolve uses.</p>\n<p>The difference is that if you schedule something with setTimeout(), and then run something with Promise.resolve(), the Promise.resolve() will run first. Make those asynchronous calls seems a bit more synchronous.</p>\n<h3 id=\"Upgrade-to-IVY\"><a href=\"#Upgrade-to-IVY\" class=\"headerlink\" title=\"Upgrade to IVY\"></a>Upgrade to IVY</h3><p>In general, I suggest that you always keep your Angular version up to date.</p>\n<p>While we are on the topic of upgrades, in an enterprise environment, I suggest never to fall more than 2 major versions behind and never use the current major version. I keep my team using the latest version of the major version before the current version. This keeps us relatively current but far enough behind that someone else has figured out all the quirks of the version we are using.</p>\n<p>At a minimum, ensure you use a version that uses the IVY rendering engine to take advantage of the performance gains it introduced.</p>\n<h2 id=\"Be-smart-about-HTML-and-CSS\"><a href=\"#Be-smart-about-HTML-and-CSS\" class=\"headerlink\" title=\"Be smart about HTML and CSS\"></a>Be smart about HTML and CSS</h2><h3 id=\"Style-the-Host-of-your-Components\"><a href=\"#Style-the-Host-of-your-Components\" class=\"headerlink\" title=\"Style the Host of your Components\"></a>Style the Host of your Components</h3><p>Another place you can eak out a bit of performance without a lot of work is by eliminating the wrapping DIV element from your components.</p>\n<p>Most Angular developers are unaware that when the HTML template is rendered, the tag you use to render the component is also rendered.  So if you have a component who‚Äôs tag is &lt;foo&gt; and inside that component you included a DIV element that wraps all your control‚Äôs content, what actually renders on the screen is</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">foo</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    html for component here</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Now, it is true that the &lt;foo&gt; will get ignored by the browser. But it still has to evaluate it and determine that it shouldn‚Äôt do anything with it and it is extra context that has to be packaged by webpack.</p>\n<p>By styling &lt;foo&gt; to look like a DIV element by using</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:host</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  ... whatever other styling you</span><br><span class=\"line\">  might have given your <span class=\"selector-tag\">div</span> tag here</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>we can eliminate the inner DIV from our component and gain a bit of performance without going to a lot of trouble. The amount of performance gain you will see will depends on how many child components are being displayed at any one time.</p>\n<h3 id=\"Don‚Äôt-overuse-SASS-x2F-SCSS\"><a href=\"#Don‚Äôt-overuse-SASS-x2F-SCSS\" class=\"headerlink\" title=\"Don‚Äôt overuse SASS&#x2F;SCSS\"></a>Don‚Äôt overuse SASS&#x2F;SCSS</h3><p>My general advice is to use CSS for your application and SASS for your component library or theme. Although, even in your component library, most of what you need to do can be done easily with CSS.</p>\n<p>I admit. When LESS and SASS first came out, I saw all the advantages. Since then, I‚Äôve been persuaded by three events.</p>\n<p>First, if you write your Angular components small enough and use view encapsulation, you shouldn‚Äôt need any of the features that SASS would provide.</p>\n<p>Second, I‚Äôve seen SASS abused more often than I‚Äôve seen it used well. One project I worked on had 200 character class names because one of the developers was using &amp; to concatenate the class names. The template code was cluttered with these long class names, making it difficult to read. Please! Don‚Äôt do this to your future self!</p>\n<p>Third, CSS has grown up. CSS variables now do most of what we may have needed to use SASS for. And, if you can keep your font and color information strictly in a theme.css file, you should never need to access them from your application components.</p>\n<p>Simple CSS is performant CSS.</p>\n<h3 id=\"ng-content-Bad-Practices\"><a href=\"#ng-content-Bad-Practices\" class=\"headerlink\" title=\"ng-content Bad Practices\"></a>ng-content Bad Practices</h3><p>I‚Äôve only recently realized that some of you are doing some pretty strange things with <code>ng-content</code>, and then you wonder why your application is slow.</p>\n<p>As a refresher, &#96;ng-content&#96;&#96; is what you use when you want to use content projection to pass content into a component. For example, if you wanted to pass in a list of items to a component, you might do something like this:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let item of items&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;item&#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Now, the first thing you should ask yourself here is, ‚ÄúDo I need to use content projection here?‚Äù</p>\n<p>We‚Äôve found a significant performance penalty for using content projection. So, if you can avoid it, you should.</p>\n<p>Notice, I said avoid. Not eliminate. There are some valid reasons for using content projections. For example, low-level components often need to use content projection because they could be a container for displaying anything.</p>\n<p>But, if you are using content projection to display exactly the same content or choice of content every time, consider eliminating the content projection and just hard-coding the content into the component. This will make the code easier to understand, and it will make the content render faster.</p>\n<p>The other crazy implementation I‚Äôve seen recently is using ngIf inside ng-content.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ng-content</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">&quot;foobar&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>It may not be obvious, but you should evaluate your DOM when the page is rendered with foobar equal to false. What you‚Äôll see may surprise you. Inside of ng-content will be all the elements that are projected into the ng-content DOM element, but they will all be hidden.</p>\n<p>So what? So, they will all have to be evaluated by the browser even though they aren‚Äôt visible. This is a waste of resources and time rendering.</p>\n<h3 id=\"Data-Binding-Issues\"><a href=\"#Data-Binding-Issues\" class=\"headerlink\" title=\"Data Binding Issues\"></a>Data Binding Issues</h3><h4 id=\"innerHTML\"><a href=\"#innerHTML\" class=\"headerlink\" title=\"innerHTML\"></a>innerHTML</h4><p>Did you know that binding data to <code>innerHTML</code> is slower than binding to the interpolation markers within the element?</p>\n<p>Often, we use</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">innerHTML</span>]=<span class=\"string\">&quot;someValue&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>instead of</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;someValue&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>to get around string sanitation issues (which is another problem) but then we get someone on our team who is just learning Angular and they do this by default.</p>\n<p>In both cases, however, you‚Äôll find if you measure the performance that the interpolation markers are significantly faster than the innerHTML binding.</p>\n<h4 id=\"Avoid-Binding-to-Functions\"><a href=\"#Avoid-Binding-to-Functions\" class=\"headerlink\" title=\"Avoid Binding to Functions\"></a>Avoid Binding to Functions</h4><p>We mentioned this above but, another place where you can eak out a bit of performance is by avoiding binding to functions. If you do, you can use a pipe to memoize the return value of the function. But, using a pipe is the lazy man‚Äôs way of optimizing against the function issue.</p>\n<p>Why? Because you are still have the overhead of calling a function every time change detection runs, you just aren‚Äôt doing the calculation every time. It is better than doing the calculation but it is worse than binding to a field where the change detector can see if anything changed before it does anything else.</p>\n<p>In the interviews we run, we have a section that covers this issue. Code is clearly calling a function inside the template.  We are happy with the ‚Äúuse a pipe‚Äù answer. But I‚Äôm even more impressed if someone says something like, ‚ÄúThis should all be done on the server, or if it can‚Äôt be done on the server, it should be done when we retrieve the data from the server.‚Äù</p>\n<p>But this can‚Äôt always be done. So, if you are going to bind to a function, ask yourself, ‚Äúhow far down the stack can I move this functionality?‚Äù</p>\n<p>In order of possibilities, I‚Äôd suggest:</p>\n<ul>\n<li>Do the calculation in the pipe if nothing else is possible</li>\n<li>Do the calculation in the component‚Äôs TS file when the @Input() value changes</li>\n<li>Do the calculation in a Selector that the component is looking at</li>\n<li>Do the calculation right after you retrieve the data from the server</li>\n<li>Do the calculation on the server</li>\n</ul>\n<h3 id=\"HostBinding\"><a href=\"#HostBinding\" class=\"headerlink\" title=\"HostBinding()\"></a>HostBinding()</h3><p>Related to binding to functions, keep in mind that @HostBinding is databinding.  If you @HostBinding is using a function, it has the same issues as binding to a function in the template.</p>\n<h3 id=\"Dynamic-CSS-Classes\"><a href=\"#Dynamic-CSS-Classes\" class=\"headerlink\" title=\"Dynamic CSS Classes\"></a>Dynamic CSS Classes</h3><p>There are multiple ways of dynamically adding classes to an element. Each one of them, essentially do the same thing. But worse, they all do them individually. So, if you end up using all three methods in your code, you are going to make at least 3 calls to the DOM to add or remove the class.</p>\n<p>Currently, using <code>ngClass</code> adds and removes each class in it individually. You‚Äôd think it would be optimized to add them more efficiently but currently (2023-11-11) they do not.</p>\n<p>I‚Äôm hoping this gets fixed by the next major version of Angular.</p>\n<h3 id=\"SVG-references-vs-SVG-inlining\"><a href=\"#SVG-references-vs-SVG-inlining\" class=\"headerlink\" title=\"SVG references vs SVG inlining\"></a>SVG references vs SVG inlining</h3><p>Another similar, hidden performance issue is the use of SVG Inlining. When you inject an SVG image into the page using inlining, the browser must evaluate the DOM elements. If you inline the same SVG image multiple times, the browser has to evaluate the DOM elements multiple times.</p>\n<p>The cure is to inline the SVG images once, and then, when you need to display the image, you can reference it using the SVG reference mechanism. There are multiple ways you might do this. One is to load them up front using a sprite and inject the sprite into the DOM. Another would be to inject the SVG image into the DOM using JavaScript the first time it is used and then reference it from that point forward.</p>\n<h3 id=\"Measure-your-CSS\"><a href=\"#Measure-your-CSS\" class=\"headerlink\" title=\"Measure your CSS\"></a>Measure your CSS</h3><p>The most overlooked area of performance I know of is measuring CSS. I can‚Äôt go into a lot of detail about this here because it would take far too much time to explain (and read about) but there are good articles on the internet that discuss measuring browser performance using flame charts and other mechanisms that are part of your browser‚Äôs developer tools.</p>\n<h2 id=\"Compile-for-Production\"><a href=\"#Compile-for-Production\" class=\"headerlink\" title=\"Compile for Production\"></a>Compile for Production</h2><p>Another place where we shouldn‚Äôt have to mention that it is even an option is compiling for production.¬†</p>\n<p>In one product I worked on, I discovered we were deploying code using the development environment instead of the production environment. I only discovered this because we were getting the change detection after change warning in production. That‚Äôs the most notable difference. But this check happens with every change detection cycle and further slows down the code.</p>\n<h2 id=\"Cache-your-code-on-the-browser\"><a href=\"#Cache-your-code-on-the-browser\" class=\"headerlink\" title=\"Cache your code on the browser\"></a>Cache your code on the browser</h2><p>If you build your application with an option that attaches a hash code to the file name, you can cache your javascript code on the browser so that the next time that browser tries to access the code, it will load it from the cache.</p>\n<p>Do not cache your index.html file, as you need to make sure that file always gets downloaded.</p>\n<p>Specifically, the options you want to implement on your server for your static files are:</p>\n<ul>\n<li>immutable</li>\n<li>max-age 365</li>\n</ul>\n<p>This will prevent the browser from even checking the server for new code.</p>\n<h2 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h2><p>Similarly, putting your files closer to the people retrieving them will improve your performance around ‚Äútime to first render.‚Äù</p>\n<h2 id=\"Perception-Beats-Reality\"><a href=\"#Perception-Beats-Reality\" class=\"headerlink\" title=\"Perception Beats Reality\"></a>Perception Beats Reality</h2><p>One place that gets overlooked when discussing performance is the ‚Äútime to first render.‚Äù</p>\n<p>We recently ran into a situation where the code took so long to load that the client didn‚Äôt even see the spinner we had put in place to indicate we were loading data.</p>\n<p>To fix this, we added spinner code directly into our html file. It takes slightly longer to load the index.html file but displays more quickly than if we waited for our javascript to load.</p>\n<h2 id=\"TrackBy-X-in-ngFor\"><a href=\"#TrackBy-X-in-ngFor\" class=\"headerlink\" title=\"TrackBy X in ngFor\"></a>TrackBy X in ngFor</h2><p>Another way to eak out more performance is by implementing the <code>trackBy</code> property in your <code>ngFor</code> loops.</p>\n<p>This is particularly useful when displaying a list that updates multiple times from the server. Because it is a brand-new object, every refresh will update the whole list.</p>\n<p>By using trackBy, you can tell Angular only to update the elements in the list that have changed by whatever you specify in TrackBy.</p>\n<h2 id=\"Lazy-Loading\"><a href=\"#Lazy-Loading\" class=\"headerlink\" title=\"Lazy Loading\"></a>Lazy Loading</h2><h3 id=\"Lazy-Load-Routes\"><a href=\"#Lazy-Load-Routes\" class=\"headerlink\" title=\"Lazy Load Routes\"></a>Lazy Load Routes</h3><p>Most applications have multiple routes that they access. But even if yours doesn‚Äôt, you should set your code up to use Lazy Loading for three reasons.</p>\n<p>First, small apps grow up. Eventually, you will have multiple routes. If your app is so small that it doesn‚Äôt, implementing Lazy Loading of routes isn‚Äôt going to hurt anything.</p>\n<p>Second, implementing Lazy Loading will break your code down further into multiple files. Most of the code in those files will never change, so once they are loaded and cached as instructed above, the only code that will ever need to be downloaded is code in your route when it changes.</p>\n<p>Third, having more files to download could help in the initial load of your application, as the client now has more opportunities to download the files in parallel. Measure this! I‚Äôve seen this overused to the point of causing worse performance!</p>\n<h3 id=\"Pre-load-Lazy-Loaded-Routes\"><a href=\"#Pre-load-Lazy-Loaded-Routes\" class=\"headerlink\" title=\"Pre-load Lazy Loaded Routes\"></a>Pre-load Lazy Loaded Routes</h3><p>Once you‚Äôve started your app, you should load all the other routes in the background so your customer doesn‚Äôt have to wait for the next page to render.</p>\n<p>This is even more important when your application is on a mobile device that doesn‚Äôt have an Internet connection at times.</p>\n<p>You can also be selective about which routes you pre-load.</p>\n<h3 id=\"Lazy-Loading-Resources\"><a href=\"#Lazy-Loading-Resources\" class=\"headerlink\" title=\"Lazy Loading Resources\"></a>Lazy Loading Resources</h3><p>Angular does most of this for you. Especially as it concerns CSS, but if your application has a lot of images, you should consider lazy loading those images.</p>\n<h3 id=\"Virtual-Scrolling\"><a href=\"#Virtual-Scrolling\" class=\"headerlink\" title=\"Virtual Scrolling\"></a>Virtual Scrolling</h3><p>There are multiple implementations of this. But the idea is only to render what the user can see as the user scrolls rather than rendering everything into the DOM and then letting the browser to the scrolling.</p>\n<p>I reduced the rendering time from 8 seconds to 1 second on one mega app I worked on by implementing this concept.</p>\n<h2 id=\"Good-Architecture\"><a href=\"#Good-Architecture\" class=\"headerlink\" title=\"Good Architecture\"></a>Good Architecture</h2><h3 id=\"General-Patterns-and-Practices\"><a href=\"#General-Patterns-and-Practices\" class=\"headerlink\" title=\"General Patterns and Practices\"></a>General Patterns and Practices</h3><p>I‚Äôve worked on optimizing an application where one of the first things we did was to straighten out the basic architecture.<br>I often tell people, ‚ÄúIf you had any idea how software gets created, you‚Äôd be amazed that anything works as well as it does.‚Äù This application was no different.</p>\n<p>Someone had wanted to implement a feature in the next version of NgRX, so they copied code from the next version into the version we were using.</p>\n<p>It sounds harmless. But the result was the NgRX change detection got thrown into a loop that took thousands of cycles to resolve instead of just one or two. This, in turn, slowed the rendering time down on the application to a point where just switching routes took multiple seconds. On the order of 5‚Äì10 seconds.</p>\n<p>Upgrading the application to the version we wanted to use solved the problem.</p>\n<p>Other similar issues with this code were solved simply by fixing how the code had been assembled.</p>\n<h3 id=\"Avoid-Code-That-Changes-Angular\"><a href=\"#Avoid-Code-That-Changes-Angular\" class=\"headerlink\" title=\"Avoid Code That Changes Angular\"></a>Avoid Code That Changes Angular</h3><p>Similar to the issue above is code that adds directives or other functionality that changes how Angular fundamentally works.</p>\n<p>There are two major reasons for this. The first is that we always want to be able to enlist people to help us with our code. Most of the time, we are trying to hire good Angular developers. If our code no longer looks like Angular, why hire Angular developers?</p>\n<p>Second, if the code changes how Angular works, it is probably hooking into some Angular internal that could change in a subsequent version of Angular. This means that you will have to wait for the code‚Äôs author to update their code before you can upgrade your application.</p>\n<p>Third, you can‚Äôt be sure some little project that thought it would be cool to add some feature to Angular to get around some perceived issue has fully tested their code. You could introduce a bug into your application that you must track down.</p>\n<p>Finally, you have to ask yourself. Does this feature, or set of features, solve a problem that would still exist if I‚Äôd written my code correctly in the first place? The one package I have in mind as I write this has contributed more to the technical debt on my project than any other package or programmer we‚Äôve had interact with our code.</p>\n<p>Be careful what code you allow into your application; it could cost you far more than it is worth in the long run.</p>\n<h2 id=\"Data-Access\"><a href=\"#Data-Access\" class=\"headerlink\" title=\"Data Access\"></a>Data Access</h2><p>So far, we‚Äôve talked about what to do once we‚Äôve retrieved the data into our application, but many performance issues can be avoided simply by paying attention to how and when we load our data from the server.</p>\n<h3 id=\"Only-Load-What-You-Need\"><a href=\"#Only-Load-What-You-Need\" class=\"headerlink\" title=\"Only Load What You Need\"></a>Only Load What You Need</h3><p>One guiding principle for data access is that you should only load the data you need from the server at the point you need it.</p>\n<p>An example of where you might see this performance issue is that we tend to do a massive join of data on the server and return everything we retrieved, even if we don‚Äôt need the data for the operation at hand.</p>\n<p>The less data you access, the faster your application will perform.</p>\n<h3 id=\"Normalization-is-a-Curse\"><a href=\"#Normalization-is-a-Curse\" class=\"headerlink\" title=\"Normalization is a Curse\"></a>Normalization is a Curse</h3><p>One way to send less data back to the server is to send it back in raw form rather than nested and normalized.</p>\n<p>For this, I recommend a product called Normalizr. This takes the nested data and breaks it into multiple tables. The product was originally written for client-side code to make using Redux and NgRX easier. But there are now server-side implementations you can use that structure the data before sending it back so that you only send back one instance of the data you need rather than multiple instances because multiple parent rows use it.</p>\n<p>Better than using Normalizr, which is now a bit dated, you should consider only asking for un-normalized data from the server and dumping it into NgRX entities. You can use NgRX selectors to join the data together however needed. Now that everyone should at least be using HTTP2, the cost of simultaneously making multiple requests to the server is negligible.</p>\n<h3 id=\"Pre-load-Lookup-Tables\"><a href=\"#Pre-load-Lookup-Tables\" class=\"headerlink\" title=\"Pre-load Lookup Tables\"></a>Pre-load Lookup Tables</h3><p>Along with this same idea. We often have nested data that is the result of some lookup table. By using Normalizr, you could load those tables up front and then only return the key to those tables and use Normalizr and NgRX Selectors to do the JOIN on the client side, further reducing the overall amount of data that you need to retrieve at any one time.</p>\n<h3 id=\"Virtual-Arrays\"><a href=\"#Virtual-Arrays\" class=\"headerlink\" title=\"Virtual Arrays\"></a>Virtual Arrays</h3><p>I mentioned Virtual Scrolling above as one way to reduce the rendering time. By combining this with a concept I refer to as Virtual Arrays, you can similarly only retrieve the data the user can see, further reducing the perceived time to render.</p>\n<p>A Virtual Array is an object that looks like an array from an API perspective, but the implementation uses the database as the storage location. You can either retrieve the data from the database whenever it is requested from the array or memoize it so that it is only retrieved once.</p>\n<h2 id=\"Memory-Management\"><a href=\"#Memory-Management\" class=\"headerlink\" title=\"Memory Management\"></a>Memory Management</h2><p>When most people think of performance, they immediately think of ‚Äúhow to impact the performance of good code.‚Äù But the most overlooked performance issue in JavaScript generally is memory. Specifically memory leaks.</p>\n<p>There are now several tools available for detecting and tracking down memory leaks. Find one and use it.</p>\n<h2 id=\"Micro-Tweaks\"><a href=\"#Micro-Tweaks\" class=\"headerlink\" title=\"Micro Tweaks\"></a>Micro Tweaks</h2><h2 id=\"Avoid-Iterators\"><a href=\"#Avoid-Iterators\" class=\"headerlink\" title=\"Avoid Iterators\"></a>Avoid Iterators</h2><p>As a general rule, using forEach, for&#x2F;of, Array.map, Array.forEach, etc is slower than using for&#x2F;next because all but the for&#x2F;next loop uses the iterator under the hood which has a significant cost. If you know your loop is going to be small, it probably doesn‚Äôt matter but if you are iterating over a large array, you should consider using for&#x2F;next instead.</p>\n<p>I‚Äôve created a forNext() function that takes an array and a callback function so that I still enjoy the benefits of forEach without the cost of using the iterator.</p>\n<p>For an extra (micro) performance boost, you should make the callback function a standard, named, function instead of an anonymous or fat arrow function.</p>\n<h2 id=\"Leverage-Iterators\"><a href=\"#Leverage-Iterators\" class=\"headerlink\" title=\"Leverage Iterators\"></a>Leverage Iterators</h2><p>On the other hand, if there is a lot of setup code in your loop to get you to a point where you can start processing the loop, and you do that pre-processing multiple times per instance, you might consider creating your own iterator and doing your setup in the constructor so you can iterate through the data without having to do the setup each time.</p>\n<p>Use the right tool for the job üòÅ.</p>\n<h2 id=\"Avoid-Duplicate-Work\"><a href=\"#Avoid-Duplicate-Work\" class=\"headerlink\" title=\"Avoid Duplicate Work\"></a>Avoid Duplicate Work</h2><h3 id=\"Arrays\"><a href=\"#Arrays\" class=\"headerlink\" title=\"Arrays\"></a>Arrays</h3><p>One obvious place to avoid duplicate work is with the Array map, filter, reduce, etc. functions. When you use these functions chained to each other, you are creating a new array for each function in the chain.</p>\n<p>Again, this may not make a significant difference with a sort array, but it can be a significant performance hit with a large array.</p>\n<h3 id=\"RxJS\"><a href=\"#RxJS\" class=\"headerlink\" title=\"RxJS\"></a>RxJS</h3><p>You‚Äôll also find that you are performing more work than you need to because you are using RxJS operators such as combineLatest() incorrectly.</p>\n<p>Here‚Äôs a tip. If you are using combineLatest() to combine selectors, consider creating a selector instead. In this way, you‚Äôll take advantage of the memoization that NgRX provides.</p>\n<p>Speaking of Selectors, avoid using factory selectors aka parameterized selectors. They can‚Äôt take advantage of memoization. Instead, make the parameter part of the state and use a normal selector. While this isn‚Äôt always possible, when you can do this, you‚Äôll naturally take advantage of memoization and improve your performance.</p>\n<h3 id=\"DevTools\"><a href=\"#DevTools\" class=\"headerlink\" title=\"DevTools\"></a>DevTools</h3><p>Unless you use the profiling tools that are part of the browser‚Äôs developer tools, you won‚Äôt know where your performance issues are. You can‚Äôt fix what you can‚Äôt measure.</p>\n<p>Get comfortable with the performance tools in your browser‚Äôs developer tools. They are your best friend when it comes to optimizing your application.</p>\n<h3 id=\"Control-your-object‚Äôs-shape\"><a href=\"#Control-your-object‚Äôs-shape\" class=\"headerlink\" title=\"Control your object‚Äôs shape\"></a>Control your object‚Äôs shape</h3><p>Under the hood, every object you create generates a Class in the browser‚Äôs memory. Even object literals end up creating a Class. This is a way the browser tries to optimize your code. Great.</p>\n<p>Now the bad news. If you add a field to an object, or reorder the fields in an object, the browser has to create a new Class for that object or decide it isn‚Äôt worth it and forget about using that optimization for the object. Something as simple as using the spread operator and then putting the changed field at the end of the object can cause the browser to deoptimize the object.</p>\n<p>If you can, create your objects as classes and, when you change the object, use the class to do it so you can keep the shape of the object the same as it is being used.</p>\n<h3 id=\"Service-Workers\"><a href=\"#Service-Workers\" class=\"headerlink\" title=\"Service Workers\"></a>Service Workers</h3><p>Similar in concept to the virtual arrays above but a standard API that you can implement globally. You can use service workers to cache data from the server and only ask the server for it again after you consider it stale.</p>\n<p>You can also use this to cache the index.html file locally, so you don‚Äôt have to retrieve it until there is a new version.</p>\n<h3 id=\"WebAssembly\"><a href=\"#WebAssembly\" class=\"headerlink\" title=\"WebAssembly\"></a>WebAssembly</h3><p>I‚Äôve yet to find my code is so slow that this actually makes sense, but it is theoretically possible that you‚Äôd find even more performance by creating services using WebAssembly. This would mean you‚Äôd need to write the code in something other than TypeScript and Angularize it by wrapping it in TypeScript&#x2F;Angular code. But I‚Äôve seen at least one article on the web where they did just that.</p>\n<h3 id=\"WebWorkers-and-Shared-Workers\"><a href=\"#WebWorkers-and-Shared-Workers\" class=\"headerlink\" title=\"WebWorkers and Shared Workers\"></a>WebWorkers and Shared Workers</h3><p>This is another place where there is at least a theoretical possibility that it would provide additional performance. At the very least, it can provide the appearance of performance.</p>\n<p>Some places to consider using Shared Workers specifically are with Web Sockets and Data Retrieval. By placing Web Socket listeners in a Shared Worker, you create one connection to the server. The Shared Worker can then relay those messages to the client code on as many windows as are currently open.</p>\n<p>Similarly, by using a Shared Worker as the main place that retrieves your data, you can cache the data and rebroadcast the new data to all the open browser windows listening to the Shared Worker.</p>\n<h2 id=\"Server-Side-Considerations\"><a href=\"#Server-Side-Considerations\" class=\"headerlink\" title=\"Server Side Considerations\"></a>Server Side Considerations</h2><h3 id=\"Normalization-is-a-Curse-Here-Too\"><a href=\"#Normalization-is-a-Curse-Here-Too\" class=\"headerlink\" title=\"Normalization is a Curse Here Too\"></a>Normalization is a Curse Here Too</h3><p>I once worked on an application where the data was being retrieved from 20 tables joined together. When we looked at what was going on, we realized that most of that data was static when the client was using it and that we could dump most of the join results into a flat table and use it instead. This was another case where we went from an 8-second load time to 1 second.</p>\n<p>The performance considerations around JOINs vary depending on what database you are using. But it is something to keep in mind all the same.</p>\n<h3 id=\"Server-Side-Caching\"><a href=\"#Server-Side-Caching\" class=\"headerlink\" title=\"Server Side Caching\"></a>Server Side Caching</h3><p>In many systems similar to the one I mentioned above, most of our calls to the server could be considered Functionally pure enough that we could cache the data.</p>\n<p>I <a href=\"/what%E2%80%99s-the-truth-about-running-asp-net-webapi-asynchronously/\">did some timings on this several years ago</a> and the results, even caching for a second, gave some pretty impressive results.</p>\n<p>For example, those lookup tables I discussed earlier don‚Äôt need to be retrieved from the database every time we make a call for them. We should be able to make a call for the data once and then return that data every time it is requested until the data is refreshed.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>There are probably other ways to optimize your application that I‚Äôve forgotten or, more likely, do out of habit now.</p>\n<p>What I‚Äôve written about above are the ones that stand out as the often overlooked issues.</p>\n",
            "tags": [
                "angular",
                "performance",
                "best practice"
            ]
        }
    ]
}